"""
Vulnerability Detection System for Digital Twins
"""

import numpy as np
from typing import Dict, List, Any
from datetime import datetime
import re

class VulnerabilityDetector:
    """Detects vulnerabilities in digital twin entities"""
    
    def __init__(self, config):
        self.config = config
        self.vulnerability_patterns = self._initialize_patterns()
        self.detection_rules = self._initialize_detection_rules()
        
    def _initialize_patterns(self) -> Dict[str, Any]:
        """Initialize vulnerability detection patterns"""
        return {
            'weak_passwords': {
                'patterns': [
                    r'password',
                    r'admin',
                    r'123456',
                    r'default',
                    r'guest'
                ],
                'severity': 'high',
                'description': 'Weak or default password detected'
            },
            'outdated_firmware': {
                'patterns': [
                    r'FW-1\.',
                    r'FW-2\.',
                    r'v1\.0',
                    r'v2\.0'
                ],
                'severity': 'medium',
                'description': 'Outdated firmware version detected'
            },
            'unencrypted_communication': {
                'patterns': [
                    r'HTTP',
                    r'FTP',
                    r'TCP'
                ],
                'severity': 'high',
                'description': 'Unencrypted communication protocol detected'
            },
            'open_ports': {
                'patterns': [
                    r'22',   # SSH
                    r'21',   # FTP
                    r'23',   # Telnet
                    r'3389'  # RDP
                ],
                'severity': 'medium',
                'description': 'Potentially dangerous open port detected'
            },
            'weak_encryption': {
                'patterns': [
                    r'MD5',
                    r'SHA1',
                    r'DES',
                    r'RC4'
                ],
                'severity': 'high',
                'description': 'Weak encryption algorithm detected'
            }
        }
    
    def _initialize_detection_rules(self) -> List[Dict[str, Any]]:
        """Initialize detection rules"""
        return [
            {
                'name': 'security_config_check',
                'function': self._check_security_config,
                'weight': 0.3
            },
            {
                'name': 'performance_anomaly_check',
                'function': self._check_performance_anomalies,
                'weight': 0.2
            },
            {
                'name': 'connectivity_risk_check',
                'function': self._check_connectivity_risks,
                'weight': 0.25
            },
            {
                'name': 'specification_vulnerability_check',
                'function': self._check_specification_vulnerabilities,
                'weight': 0.25
            }
        ]
    
    def detect_vulnerabilities(self, entities: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Detect vulnerabilities in all entities"""
        all_vulnerabilities = []
        
        for entity_id, entity in entities.items():
            vulnerabilities = self._analyze_entity(entity)
            all_vulnerabilities.extend(vulnerabilities)
        
        return all_vulnerabilities
    
    def _analyze_entity(self, entity: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Analyze a single entity for vulnerabilities"""
        vulnerabilities = []
        
        # Apply detection rules
        for rule in self.detection_rules:
            rule_vulns = rule['function'](entity)
            vulnerabilities.extend(rule_vulns)
        
        # Pattern-based detection
        pattern_vulns = self._pattern_based_detection(entity)
        vulnerabilities.extend(pattern_vulns)
        
        # ML-based anomaly detection
        ml_vulns = self._ml_based_detection(entity)
        vulnerabilities.extend(ml_vulns)
        
        return vulnerabilities
    
    def _check_security_config(self, entity: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check security configuration for vulnerabilities"""
        vulnerabilities = []
        security_config = entity.get('security_config', {})
        
        # Check encryption
        if not security_config.get('encryption_enabled', False):
            vulnerabilities.append({
                'type': 'encryption_disabled',
                'severity': 'high',
                'description': 'Encryption is not enabled',
                'affected_system': entity['name'],
                'entity_id': entity['id'],
                'confidence': 0.95
            })
        
        # Check authentication
        if not security_config.get('authentication_required', False):
            vulnerabilities.append({
                'type': 'no_authentication',
                'severity': 'critical',
                'description': 'No authentication required',
                'affected_system': entity['name'],
                'entity_id': entity['id'],
                'confidence': 0.98
            })
        
        # Check firewall
        if not security_config.get('firewall_enabled', False):
            vulnerabilities.append({
                'type': 'firewall_disabled',
                'severity': 'medium',
                'description': 'Firewall is not enabled',
                'affected_system': entity['name'],
                'entity_id': entity['id'],
                'confidence': 0.90
            })
        
        # Check patch management
        if security_config.get('patch_management') == 'none':
            vulnerabilities.append({
                'type': 'no_patch_management',
                'severity': 'high',
                'description': 'No patch management system in place',
                'affected_system': entity['name'],
                'entity_id': entity['id'],
                'confidence': 0.85
            })
        
        return vulnerabilities
    
    def _check_performance_anomalies(self, entity: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check for performance anomalies that might indicate vulnerabilities"""
        vulnerabilities = []
        metrics = entity.get('performance_metrics', {})
        
        # Check for unusual CPU usage
        cpu_usage = metrics.get('cpu_usage', 0)
        if cpu_usage > 90:
            vulnerabilities.append({
                'type': 'high_cpu_usage',
                'severity': 'medium',
                'description': f'Unusually high CPU usage: {cpu_usage:.1f}%',
                'affected_system': entity['name'],
                'entity_id': entity['id'],
                'confidence': 0.7
            })
        
        # Check for unusual memory usage
        memory_usage = metrics.get('memory_usage', 0)
        if memory_usage > 95:
            vulnerabilities.append({
                'type': 'high_memory_usage',
                'severity': 'medium',
                'description': f'Unusually high memory usage: {memory_usage:.1f}%',
                'affected_system': entity['name'],
                'entity_id': entity['id'],
                'confidence': 0.7
            })
        
        # Check for high error rate
        error_rate = metrics.get('error_rate', 0)
        if error_rate > 0.1:
            vulnerabilities.append({
                'type': 'high_error_rate',
                'severity': 'high',
                'description': f'High error rate: {error_rate:.3f}',
                'affected_system': entity['name'],
                'entity_id': entity['id'],
                'confidence': 0.8
            })
        
        return vulnerabilities
    
    def _check_connectivity_risks(self, entity: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check connectivity for security risks"""
        vulnerabilities = []
        connectivity = entity.get('connectivity', {})
        
        for connection in connectivity.get('connections', []):
            # Check for unencrypted connections
            if not connection.get('encrypted', False):
                vulnerabilities.append({
                    'type': 'unencrypted_connection',
                    'severity': 'high',
                    'description': f'Unencrypted {connection.get("protocol", "unknown")} connection',
                    'affected_system': entity['name'],
                    'entity_id': entity['id'],
                    'confidence': 0.9
                })
            
            # Check for dangerous ports
            port = connection.get('port', 0)
            dangerous_ports = [21, 22, 23, 3389, 445, 1433]
            if port in dangerous_ports:
                vulnerabilities.append({
                    'type': 'dangerous_port_open',
                    'severity': 'medium',
                    'description': f'Potentially dangerous port {port} is open',
                    'affected_system': entity['name'],
                    'entity_id': entity['id'],
                    'confidence': 0.8
                })
        
        return vulnerabilities
    
    def _check_specification_vulnerabilities(self, entity: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check entity specifications for known vulnerabilities"""
        vulnerabilities = []
        specs = entity.get('specifications', {})
        
        # Check for outdated operating systems
        os = specs.get('operating_system', '').lower()
        outdated_os = ['windows xp', 'windows 7', 'windows server 2008']
        if any(old_os in os for old_os in outdated_os):
            vulnerabilities.append({
                'type': 'outdated_operating_system',
                'severity': 'high',
                'description': f'Outdated operating system: {os}',
                'affected_system': entity['name'],
                'entity_id': entity['id'],
                'confidence': 0.95
            })
        
        # Check firmware version
        firmware = specs.get('firmware_version', '')
        if firmware.startswith('FW-1.') or firmware.startswith('FW-2.'):
            vulnerabilities.append({
                'type': 'outdated_firmware',
                'severity': 'medium',
                'description': f'Outdated firmware: {firmware}',
                'affected_system': entity['name'],
                'entity_id': entity['id'],
                'confidence': 0.85
            })
        
        return vulnerabilities
    
    def _pattern_based_detection(self, entity: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Detect vulnerabilities using pattern matching"""
        vulnerabilities = []
        entity_str = str(entity).lower()
        
        for vuln_type, pattern_info in self.vulnerability_patterns.items():
            for pattern in pattern_info['patterns']:
                if re.search(pattern.lower(), entity_str):
                    vulnerabilities.append({
                        'type': vuln_type,
                        'severity': pattern_info['severity'],
                        'description': pattern_info['description'],
                        'affected_system': entity['name'],
                        'entity_id': entity['id'],
                        'confidence': 0.75
                    })
                    break  # Only report each vulnerability type once per entity
        
        return vulnerabilities
    
    def _ml_based_detection(self, entity: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Use machine learning to detect anomalies"""
        vulnerabilities = []
        
        # Extract features for ML analysis
        features = self._extract_features(entity)
        
        # Simple anomaly detection based on feature values
        anomaly_score = self._calculate_anomaly_score(features)
        
        if anomaly_score > 0.8:
            vulnerabilities.append({
                'type': 'ml_anomaly_detected',
                'severity': 'medium',
                'description': f'ML anomaly detected with score: {anomaly_score:.3f}',
                'affected_system': entity['name'],
                'entity_id': entity['id'],
                'confidence': anomaly_score
            })
        
        return vulnerabilities
    
    def _extract_features(self, entity: Dict[str, Any]) -> List[float]:
        """Extract numerical features from entity for ML analysis"""
        features = []
        
        # Performance metrics
        metrics = entity.get('performance_metrics', {})
        features.extend([
            metrics.get('cpu_usage', 0),
            metrics.get('memory_usage', 0),
            metrics.get('network_usage', 0),
            metrics.get('disk_usage', 0),
            metrics.get('response_time', 0),
            metrics.get('error_rate', 0)
        ])
        
        # Connectivity features
        connectivity = entity.get('connectivity', {})
        features.extend([
            len(connectivity.get('connections', [])),
            connectivity.get('total_bandwidth', 0),
            connectivity.get('network_latency', 0)
        ])
        
        # Security features (binary)
        security_config = entity.get('security_config', {})
        features.extend([
            1.0 if security_config.get('encryption_enabled', False) else 0.0,
            1.0 if security_config.get('authentication_required', False) else 0.0,
            1.0 if security_config.get('firewall_enabled', False) else 0.0,
            1.0 if security_config.get('intrusion_detection', False) else 0.0
        ])
        
        return features
    
    def _calculate_anomaly_score(self, features: List[float]) -> float:
        """Calculate anomaly score using simple statistical methods"""
        if not features:
            return 0.0
        
        # Normalize features
        features = np.array(features)
        features = (features - np.mean(features)) / (np.std(features) + 1e-8)
        
        # Calculate anomaly score based on distance from mean
        anomaly_score = np.mean(np.abs(features))
        
        # Normalize to [0, 1] range
        anomaly_score = min(1.0, anomaly_score / 3.0)
        
        return anomaly_score 